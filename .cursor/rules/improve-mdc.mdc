---
description: "Continuously analyze the coding-assistant activity log to refine .cursor/rules/work-on-features.mdc so tasks finish faster without weakening quality gates"
alwaysApply: false
---

This rule directs the assistant to treat logs/coding.log as a chronological record of the coding assistant’s own actions and outcomes rather than application runtime output, 
and to use evidence from that record to refine .cursor/rules/work-on-features.mdc so that checklist items complete faster while preserving all existing Definition of Done and 
testing standards. The goal is to reduce idle time, loops, and indecision in the automation without relaxing quality, safety, or traceability requirements.

Begin by establishing an objective baseline from the activity log. Segment iterations using the log’s date lines, phase banners, success markers, and error codes to measure 
typical and worst case durations from iteration start to completion. Summarize the frequency and causes of timeouts, repeated retries without new information, empty or no-op 
commits, oscillation between tasks, and restarts caused by ambiguous instructions. Record this baseline concisely in the next commit message so that it remains reproducible 
and visible to maintainers without adding new files.

Interpret recurrent slowdowns as prompt-level shortcomings. Treat repeated rediscovery of repository state, hesitation in task selection, verbose status chatter that 
displaces actionable work, redundant command reruns, and unnecessary checklist scans as symptoms of unclear or incomplete guidance in .cursor/rules/work-on-features.mdc. 
Identify exactly which parts of that rule invite ambiguity, such as vague preflight steps, weak continuity instructions that fail to use the latest portion of 
logs/coding.log, imprecise ordering for equal priority tasks, unclear commit isolation rules, or missing timeboxing and fallback behavior for long-running or flaky commands.

Draft a focused revision to .cursor/rules/work-on-features.mdc that addresses these causes directly while explicitly reaffirming all quality gates from the project’s 
Definition of Done and diverse testing requirements. Strengthen preflight continuity by requiring the assistant to consult the recent tail of logs/coding.log to resume 
precisely where work last ended rather than repeating exploratory steps. Clarify deterministic task ordering and tie-breaks so selection is immediate and stable. Tighten 
instructions for keeping commits small and isolated, including restaging when unrelated changes enter the index. Add explicit timeboxing and recovery guidance so that when a 
command exceeds a sensible window the assistant narrows scope, switches to a safer subtask, or captures minimal diagnostics before proceeding. Require concise, operational 
output over narrative status text to reduce token and time overhead while keeping essential evidence in the log.

Validate the revision by running a representative unchecked checklist item end to end and measuring iteration time again from the log using the same method as the baseline. 
Accept the change only if the result shows faster completion without any relaxation of tests, gates, or documentation obligations and with all checks green. If the outcome is 
not both faster and sound, iterate on the wording and repeat the validation until the improvement is demonstrated or until further changes would risk weakening constraints.

Commit only the refined .cursor/rules/work-on-features.mdc and a brief baseline and after summary in the commit message explaining what changed and why it improves 
throughput. Do not push to remotes and do not modify unrelated files. When additional improvements are discovered that are safe but out of scope for a single change, add a 
concise follow-up entry to FEATURE_CHECKLIST.md so that optimization proceeds in small, verifiable steps. Resolve any merge conflicts in the rule conservatively by 
preserving proven constraints, integrating one clarification at a time, and revalidating behavior after each integration.
