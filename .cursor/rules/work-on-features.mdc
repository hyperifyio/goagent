---
description: "Work on FEATURE_CHECKLIST.md items faster using log-tail continuity, deterministic task ordering, strict timeboxing, and commit isolation — without weakening Definition of Done or tests"
alwaysApply: false
---

You are the coding assistant working inside this repository. Optimize for throughput while strictly upholding the repository’s Definition of Done (DoD), testing standards, and traceability requirements. Never relax gates. Prefer short, operational outputs over narrative text.

Core constraints to reaffirm (never weaken):
- All production changes are covered by automated tests; diverse tests at appropriate layers; regressions gain protecting tests.
- Full build and test suite must pass; linters/formatters/static analysis clean; no secrets in changes.
- Traceability: each commit/PR references the canonical GitHub issue URL and explains intent in plain language.
- Backward compatibility preserved unless explicitly approved with migration plan.

Preflight continuity (must do before any new work):
- Read the recent tail of `logs/coding.log` (at least last 400 lines). Extract the latest markers: `DATE:`, `--- WORKING ON ---`, `--- SUCCESSFUL END ---`, `--- ERROR:`. Resume precisely where the last successful step ended. Do not re-discover repository state if it’s already known from the tail.
- If the previous attempt ended with a timeout or repeated retries for the same command and inputs, do not re-run blindly. Narrow scope or choose a smaller subtask first.

Deterministic task selection and ordering:
- Source of truth is `FEATURE_CHECKLIST.md`.
- Selection rule:
  1) Prefer the smallest unchecked task that is self-contained and does not require external services.
  2) If multiple qualify, pick the first unchecked task top-to-bottom in `FEATURE_CHECKLIST.md`.
  3) If a task risks flakiness (network/long builds), defer it behind a smaller deterministic subtask that advances the same goal (e.g., write failing unit test first).
- Never oscillate: once a task is picked, stick to it until either completed, blocked by an external dependency, or timeboxed out with diagnostics captured.

Commit isolation and restaging discipline:
- Before committing, ensure only files relevant to the current task are staged.
- If unrelated files are staged, unstage them and stage only task-related changes.
- Keep commits small, isolated, and explanatory. The message must explain the “why” and link to the issue.

Execution timeboxing and recovery:
- Default per-shell-command budget: 90s. For slow but necessary steps (e.g., `go test ./...`), 8m max. For network calls, 30s unless the task explicitly demands longer.
- On timeouts:
  - Capture minimal diagnostics: command, parameters, and the last 50 lines of stderr/stdout.
  - Retry only once if inputs changed or you applied a concrete mitigation (e.g., limiting scope, filtering, smaller test targets).
  - Otherwise, switch to a safer subtask that progresses the same task (e.g., write a failing unit test or slice the change).
- Avoid redundant reruns: never re-run the exact same command with the same inputs if it just failed/timed out without any change.

Operational output style:
- Prefer concise bullet points and result snippets over verbose narration.
- When reading or searching, quote exactly what you searched for and summarize findings in one line.
- Log only high-signal evidence that helps the next iteration resume quickly.

Quality gates to run in this order where relevant:
- go fmt/vet/lint (or `make lint` if available).
- Unit tests first for changed packages: `go test ./...` is acceptable when scope is unclear, but prefer narrowed packages if you can determine them deterministically.
- Integration/end-to-end tests when applicable to the task.
- Security/secret checks if configured in CI; at minimum ensure no secrets are added.

Continuity-driven workflow (tight loop):
1) From `logs/coding.log` tail, identify the last selected checklist item and whether it finished. If unfinished, resume at the next smallest pending subtask.
2) If starting fresh, select the next task deterministically (rules above) from `FEATURE_CHECKLIST.md`.
3) Create or update tests first (failing) to express desired behavior. Keep test diffs minimal and focused.
4) Implement the smallest change necessary to make the test pass.
5) Run gates in the order above. If anything fails, fix before proceeding.
6) Commit only related files with a concise message explaining why and linking to the issue.
7) Record a brief operational summary in the activity log (your stdout), including elapsed times for key steps.

Traceability and evidence:
- When using tools, record command, minimal parameters (redacting secrets), duration, and pass/fail.
- When you skip or defer due to timeboxing, state the reason and the exact next step for the following iteration.

Explicit anti-patterns to avoid:
- Re-discovering repo state each loop when `logs/coding.log` already records it.
- Repeatedly scanning the entire checklist without selecting a task.
- Rerunning the same command after a failure without any new information.
- Creating empty or no-op commits.
- Excessive commentary that does not change state or add evidence.

Deterministic tie-breakers for equal-priority actions:
- Prefer actions that reduce uncertainty: reading a single most-relevant file over a broad scan; running a tight unit test over a full-suite run.
- Prefer edits over documentation unless the task is a docs task.
- Prefer local-only operations over network calls.

Definition of Done restated for every task:
- Tests exist and pass; coverage not reduced; changed lines/branches exercised.
- Code clear, readable, and aligned with repo style.
- Build, static checks, and security checks green.
- Commit message references the canonical GitHub issue and explains intent.
- No unrelated changes in the commit; migration paths documented if any breaking change was approved.
