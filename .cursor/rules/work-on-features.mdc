---
description: "Work on FEATURE_CHECKLIST.md items faster using log-tail continuity, deterministic task ordering, strict timeboxing, and commit isolation — without weakening Definition of Done or tests"
alwaysApply: false
---

You are the coding assistant working inside this repository. Optimize for throughput while strictly upholding the repository’s Definition of Done (DoD), testing standards, and traceability requirements. Never relax gates. Prefer short, operational outputs over narrative text. Reduce idle time and indecision by resuming precisely, selecting deterministically, and avoiding redundant scans or reruns.

Core constraints to reaffirm (never weaken):
- All production changes are covered by automated tests; diverse tests at appropriate layers; regressions gain protecting tests.
- Full build and test suite must pass; linters/formatters/static analysis clean; no secrets in changes.
- Traceability: each commit/PR references the canonical GitHub issue URL and explains intent in plain language.
- Backward compatibility preserved unless explicitly approved with migration plan.

Preflight continuity (must do before any new work):
- Read only the recent tail of `logs/coding.log` (last ~600 lines). If that file is missing or empty, fall back to `logs/improving.log`. If both are missing or empty, treat continuity as unavailable and start recording fresh markers for this iteration.
- Extract the latest markers: `DATE:`, `--- WORKING ON ---`, `--- SUCCESSFUL END ---`, `--- ERROR:`, plus any explicit command lines and target file paths.
- Resume from the last successful step. If the last run already listed files, targets, or exact commands, reuse them; do not re-discover the repo unless something materially changed (e.g., file added/removed since that log tail).
- If the previous attempt ended with a timeout or with a repeated retry for the same command and inputs, do not re-run as-is. Narrow scope, choose a smaller subtask, or change inputs deterministically before a single retry.
- In-run cache: within a single iteration, do not re-read the same file twice. Reference prior results from the same iteration instead of repeating searches/reads.
- At the beginning of your run, emit compact markers so the next iteration can resume precisely. Always write them to stdout and, if the repo is writable, also append the same lines to `logs/coding.log` (atomic append). Emit exactly one `DATE:` line and one `--- WORKING ON ---` banner with the exact checklist line before any commands.

Deterministic task selection and ordering:
- Source of truth is `FEATURE_CHECKLIST.md`.
- Selection rule:
  1) Prefer the smallest unchecked task that is self-contained and does not require external services.
  2) If multiple qualify, pick the first unchecked task top-to-bottom in `FEATURE_CHECKLIST.md`.
  3) If a task risks flakiness (network/long builds), defer it behind a smaller deterministic subtask that advances the same goal (e.g., write a failing unit test first).
- Once a task is picked, stick to it until completed, blocked by an external dependency, or timeboxed out. No oscillation between tasks.
- If two actions seem equally valid, apply tie-breakers below immediately; do not pause to reconsider.

Commit isolation and restaging discipline:
- Before committing, ensure only files relevant to the current task are staged.
- If unrelated files are staged, unstage them and stage only task-related changes. Deterministic sequence: `git reset -- .` then explicitly `git add` only the intended paths.
- Keep commits small, isolated, and explanatory. The message must explain the “why” and link to the issue.
- When deleting files or directories, ALWAYS use `git rm` so deletions are tracked (e.g., `git rm path/to/file` or `git rm -r path/to/dir`). To remove from Git but keep the local file, use `git rm --cached <path>`.
- If an automated hook reformats or updates files, amend the commit to include those changes. Never leave hook-modified files unstaged.

Execution timeboxing and recovery:
- Default per-shell-command budget: 90s. For slow but necessary steps (e.g., `go test ./...`), 8m max. For network calls, 30s unless the task explicitly demands longer.
- Prefer narrowed scopes: run `go test` on touched packages first; only expand to `./...` if scope is unclear or failures span packages.
- On timeouts:
  - Capture minimal diagnostics: command, parameters, duration, exit code, and the last 50 lines of stderr/stdout.
  - Retry only once if inputs changed or you applied a concrete mitigation (e.g., limiting scope, filtering, smaller test targets).
  - Otherwise, switch to a safer subtask that progresses the same task (e.g., write a failing unit test or slice the change).
- Avoid redundant reruns: never re-run the exact same command with the same inputs if it just failed/timed out without any change.

Deterministic outputs to the activity log (kept concise):
- For reads/searches, log the exact query and the count of matches, not full content.
- For commands, log: `CMD:` abridged command, scope/package, duration, exit code, pass/fail. Redact secrets.
- Suppress meta narration; prefer one-line operational entries that enable fast resumption.

Marker format (parseable, one line each):
- `DATE: <UTC RFC3339>`
- `--- WORKING ON --- <exact FEATURE_CHECKLIST.md line>`
- `TASK: <one-line subtask plan>`
- `CMD: <command> | scope=<pkg-or-path> | exit=<code> | ms=<duration>`
- `TEST: <scope> | pass=<n> | fail=<n> | ms=<duration>`
- `PASS: <short reason>` or `FAIL: <short reason>`
- `--- SUCCESSFUL END --- <line-or-id>` or `--- ERROR: <short reason> ---`

Operational output style:
- Prefer concise bullet points and result snippets over verbose narration. Avoid meta status like “I'll scan the repository…”.
- When reading or searching, quote exactly what you searched for and summarize findings in one line.
- Log only high-signal evidence that helps the next iteration resume quickly (e.g., counts, key file names, pass/fail). Do not dump full content unless essential.
- Where feasible, prefix lines with parseable tags like `TASK:`, `CMD:`, `TEST:`, `PASS:`, `FAIL:` to support fast grep-based analysis.

Search and tooling constraints:
- Prefer repository-native search tools over shell processes to avoid overhead. Use ripgrep-style queries and glob filters; avoid raw `find`/`grep` shell calls.
- Reuse results from earlier in the same iteration instead of repeating the same search/read.

Baseline and validation (for refining this rule):
- Before editing this rule, compute a baseline from the activity log (prefer `logs/coding.log`, else `logs/improving.log`). If both are missing/empty, state that baseline data is unavailable.
- Use deterministic searches to gather:
  - Counts: timeouts, retries/reruns without new info, empty/no-op commits, oscillations between tasks, ambiguous restarts.
  - Durations: if timestamps are present, estimate median and p95 iteration time between `--- WORKING ON ---` and `--- SUCCESSFUL END ---`/`--- ERROR:` markers. If timestamps are absent, record that durations are unavailable.
- In the commit message for this change, include two grep-friendly lines:
  - `Baseline: timeouts=<n>, retries=<n>, oscillations=<n>, empty_commits=<n>, durations=<p50|unavailable>/<p95|unavailable>`
  - `After: timeouts=<n>, retries=<n>, oscillations=<n>, empty_commits=<n>, durations=<p50|unavailable>/<p95|unavailable>`
- After editing this rule, validate by running one representative unchecked checklist item end to end (choose the smallest deterministic one per selection rules). Measure the same metrics again from the log tail. Accept the revision only if iteration time improves or remains equal with strictly preserved gates and all checks green.
- If improvement is not demonstrated, tighten wording that addresses the observed slowdown (continuity, ordering, timeboxing, or commit isolation) and repeat once. Prefer conservative changes over broad rewrites.

Quality gates to run in this order where relevant:
- go fmt/vet/lint (or `make lint` if available).
- Unit tests first for changed packages: select packages deterministically from edited file paths; if uncertain, run `go test ./...`.
- Integration/end-to-end tests when applicable to the task.
- Security/secret checks if configured in CI; at minimum ensure no secrets are added.

Continuity-driven workflow (tight loop):
1) From `logs/coding.log` tail, identify the last selected checklist item and whether it finished. If unfinished, resume at the next smallest pending subtask; otherwise select the next task deterministically from `FEATURE_CHECKLIST.md`.
2) Plan one minimal subtask that moves the task forward and can complete within the timebox. State it in one line.
3) Create or update tests first (failing) to express desired behavior. Keep test diffs minimal and focused.
4) Implement the smallest change necessary to make the test pass.
5) Run gates in the order above. If anything fails, fix before proceeding.
6) Commit only related files with a concise message explaining why and linking to the issue. If hooks modify files, amend to include them.
7) Record a brief operational summary in the activity log (stdout): subtask, commands run, durations, pass/fail. Include the exact checklist line text when marking completion so it’s easily grep-able later.

Traceability and evidence:
- When using tools, record command, minimal parameters (redacting secrets), duration, and pass/fail.
- When you skip or defer due to timeboxing, state the reason and the exact next step for the following iteration.
- Reference the canonical GitHub issue URL in commits and in test/PR descriptions as required by DoD.

Explicit anti-patterns to avoid:
- Re-discovering repo state each loop when `logs/coding.log` already records it.
- Re-running broad repo scans when a direct file path is already known from prior steps.
- Repeatedly scanning the entire checklist without selecting a task.
- Rerunning the same command after a failure without any new information.
- Creating empty or no-op commits.
- Excessive commentary that does not change state or add evidence.

Deterministic tie-breakers for equal-priority actions:
- Prefer actions that reduce uncertainty: reading a single most-relevant file over a broad scan; running a tight unit test over a full-suite run.
- Prefer edits over documentation unless the task is a docs task.
- Prefer local-only operations over network calls.
- Prefer previously proven commands/flags recorded in `logs/coding.log` over inventing new ones.

Definition of Done restated for every task:
- Tests exist and pass; coverage not reduced; changed lines/branches exercised.
- Code clear, readable, and aligned with repo style.
- Build, static checks, and security checks green.
- Commit message references the canonical GitHub issue and explains intent.
- No unrelated changes in the commit; migration paths documented if any breaking change was approved.

Notes and clarifications:
- Commit only this rule file when refining process guidance. Do not push to remotes. If additional safe improvements are discovered but out of scope, capture a concise follow-up in `FEATURE_CHECKLIST.md` as a separate future task.
