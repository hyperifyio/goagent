---
description: "Work on FEATURE_CHECKLIST.md items faster using log-tail continuity, deterministic task ordering, strict timeboxing, and commit isolation — without weakening Definition of Done or tests"
alwaysApply: false
---

You are the coding assistant working inside this repository. Optimize for throughput while strictly upholding the repository’s Definition of Done (DoD), testing standards, and traceability requirements. Never relax gates. Prefer short, operational outputs over narrative text. Reduce idle time and indecision by resuming precisely, selecting deterministically, and avoiding redundant scans or reruns.

Core constraints to reaffirm (never weaken):
- All production changes are covered by automated tests; diverse tests at appropriate layers; regressions gain protecting tests.
- Full build and test suite must pass; linters/formatters/static analysis clean; no secrets in changes.
- Traceability: each commit/PR references the canonical GitHub issue URL and explains intent in plain language.
- Backward compatibility preserved unless explicitly approved with migration plan.

Preflight continuity (must do before any new work):
- Read only the recent tail of `logs/coding.log` (last ~600 lines). If that file is missing or empty, fall back to `logs/improving.log`. If both are missing or empty, treat continuity as unavailable and start recording fresh markers for this iteration.
- Extract the latest markers: `DATE:`, `--- WORKING ON ---`, `--- SUCCESSFUL END ---`, `--- ERROR:`, plus any explicit command lines and target file paths.
- Resume from the last successful step. If the last run already listed files, targets, or exact commands, reuse them; do not re-discover the repo unless something materially changed (e.g., file added/removed since that log tail).
- If the previous iteration ended with a commit-only cycle (e.g., banner `--- COMMITTING UNCHANGED TO GIT ---`) and there are no staged changes, skip any commit flow entirely and proceed directly to task selection.
- If the previous attempt ended with a timeout or with a repeated retry for the same command and inputs, do not re-run as-is. Narrow scope, choose a smaller subtask, or change inputs deterministically before a single retry.
- In-run cache: within a single iteration, do not re-read the same file twice. Reference prior results from the same iteration instead of repeating searches/reads.
- At the beginning of your run, emit compact markers so the next iteration can resume precisely. Always write them to stdout and, if the repo is writable, also append the same lines to `logs/coding.log` (atomic append). Emit exactly one `DATE:` line and one `--- WORKING ON ---` banner with the exact checklist line before any commands. Do not print any lead‑in commentary before these markers.
 - Treat `logs/coding.log` as the automation activity log (not app runtime output). Prefer its latest tail for continuity instead of repeating exploratory scans.
 - Timestamps: accept both legacy RFC2822 (`date -R`) and RFC3339 in the log; when writing, prefer RFC3339.
 - If your transport prints tokenized/streamed messages (e.g., one token per line), ignore those verbose lines for continuity; rely on the compact markers you emit (`DATE:`, `--- WORKING ON ---`, `TASK:`, `CMD:`, `TEST:`, `PASS/FAIL`). Do not reproduce tokenized chatter.

Deterministic task selection and ordering:
- Source of truth is `FEATURE_CHECKLIST.md`.
- Selection rule:
  1) Prefer the smallest unchecked task that is self-contained and does not require external services.
  2) If multiple qualify, pick the first unchecked task top-to-bottom in `FEATURE_CHECKLIST.md`.
  3) If a task risks flakiness (network/long builds), defer it behind a smaller deterministic subtask that advances the same goal (e.g., write a failing unit test first).
- Once a task is picked, stick to it until completed, blocked by an external dependency, or timeboxed out. No oscillation between tasks.
- If two actions seem equally valid, apply tie-breakers below immediately; do not pause to reconsider.

Commit isolation and restaging discipline:
- Before committing, ensure only files relevant to the current task are staged.
- If unrelated files are staged, unstage them and stage only task-related changes. Deterministic sequence: `git reset -- .` then explicitly `git add` only the intended paths.
- Never run `git add .` as part of your own flow. Always add explicit paths for the current task only. If an external script has pre‑staged unrelated files, unstage them deterministically before proceeding.
- Keep commits small, isolated, and explanatory. The message must explain the “why” and link to the issue.
- When deleting files or directories, ALWAYS use `git rm` so deletions are tracked (e.g., `git rm path/to/file` or `git rm -r path/to/dir`). To remove from Git but keep the local file, use `git rm --cached <path>`.
- If an automated hook reformats or updates files, amend the commit to include those changes. Never leave hook-modified files unstaged.
 - Never create a commit when there are zero staged changes. Skip commit ceremony and continue working.
 - Never commit generated artifacts (built binaries or other files ignored by `.gitignore`). If such files enter the index, remove them deterministically using `git rm --cached <path>` and ensure they are ignored going forward.

Execution timeboxing and recovery:
- Default per-shell-command budget: 90s. For slow but necessary steps (e.g., `go test ./...`), 8m max. For network calls, 30s unless the task explicitly demands longer.
- Prefer narrowed scopes: run `go test` on touched packages first; only expand to `./...` if scope is unclear or failures span packages.
- On timeouts:
  - Capture minimal diagnostics: command, parameters, duration, exit code, and the last 50 lines of stderr/stdout.
  - Retry only once if inputs changed or you applied a concrete mitigation (e.g., limiting scope, filtering, smaller test targets).
  - Otherwise, switch to a safer subtask that progresses the same task (e.g., write a failing unit test or slice the change).
- Avoid redundant reruns: never re-run the exact same command with the same inputs if it just failed/timed out without any change.

Rerun guard (within and across iterations):
- Before issuing a command, compare it to the most recent `CMD:` entry in the log tail and to any `CMD:` you already ran in this iteration. If it is identical in command and inputs/scope, skip it and log a one‑line `SKIP: same-input` with a short reason.
- Only retry once after applying a concrete mitigation (narrowed scope, adjusted flags, smaller target). Otherwise, switch to a safer subtask.

Deterministic outputs to the activity log (kept concise):
- For reads/searches, log the exact query and the count of matches, not full content.
- For commands, log: `CMD:` abridged command, scope/package, duration, exit code, pass/fail. Redact secrets.
- Suppress meta narration; prefer one-line operational entries that enable fast resumption.
- Do not emit verbose lead-ins (e.g., lines starting with "I'll", "I'm going to"). Write the marker or command/result directly.
 - If output would be split into many tiny lines, buffer locally and emit a single concise line per marker. Never emit one word per line.

Strict chatter ban (enforced examples):
- Do not emit lines beginning with: `I'll`, `I am`, `I'm going to`, `I’m going to`.
- Replace legacy noisy lines like `Searched files (...)` or `Listed <path>` with the compact `SEARCH:` and `LIST:` markers.

Marker format (parseable, one line each — use these exact spellings so grep works deterministically):
- `DATE: <UTC RFC3339>`
- `--- WORKING ON --- <exact FEATURE_CHECKLIST.md line>`
- `TASK: <one-line subtask plan>`
- `CMD: <command> | scope=<pkg-or-path> | exit=<code> | ms=<duration>`
- `TEST: <scope> | pass=<n> | fail=<n> | ms=<duration>`
- `PASS: <short reason>` or `FAIL: <short reason>`
- `--- SUCCESSFUL END --- <line-or-id>` or `--- ERROR: <short reason> ---`
Note: Always use `--- SUCCESSFUL END ---` (do not log variants like `--- SUCCESS ---`).

Optional iteration segment markers (accepted in addition to the above for clearer boundaries):
- `ITER_START: <RFC3339>` at the very beginning (after `DATE:`), and `ITER_END: <RFC3339>` at the end. Keep both to a single line if used.

Additional lightweight markers to replace noisy chatter:
- `SEARCH: query="<pattern>" | glob=<glob-or-none> | files=<n> | matches=<n>`
- `LIST: dir=<path> | entries=<n>`

Operational output style:
- Prefer concise bullet points and result snippets over verbose narration. Avoid meta status like “I'll scan the repository…”.
- When reading or searching, quote exactly what you searched for and summarize findings in one line.
- Log only high-signal evidence that helps the next iteration resume quickly (e.g., counts, key file names, pass/fail). Do not dump full content unless essential.
- Where feasible, prefix lines with parseable tags like `TASK:`, `CMD:`, `TEST:`, `PASS:`, `FAIL:` to support fast grep-based analysis.
 - Suppress filler text in outputs (e.g., “I’m going to…”, “Then I’ll…”). Write the marker or the command/result directly.
 - Do not emit free-form lines like `Searched files (...)` or `Listed <path>`; emit `SEARCH:` or `LIST:` markers instead with counts only.

Discovery budget per iteration (to cap idle scans):
- Hard cap discovery to at most 3 `SEARCH:` and 1 `LIST:` operations before producing the first `CMD:` or `TEST:` entry, unless additional discovery is strictly necessary to proceed. Use the log tail to avoid repeats.

Search and tooling constraints:
- Prefer repository-native search tools over shell processes to avoid overhead. Use ripgrep-style queries and glob filters; avoid raw `find`/`grep` shell calls.
- Reuse results from earlier in the same iteration instead of repeating the same search/read.

Baseline and validation (for refining this rule):
- Before editing this rule, compute a baseline from the activity log (prefer `logs/coding.log`, else `logs/improving.log`). If both are missing/empty, state that baseline data is unavailable.
- Use deterministic searches to gather:
  - Counts: timeouts, retries/reruns without new info, empty/no-op commits, oscillations between tasks, ambiguous restarts.
  - Durations: if timestamps are present, estimate median and p95 iteration time between `--- WORKING ON ---` and `--- SUCCESSFUL END ---`/`--- ERROR:` markers. If timestamps are absent, record that durations are unavailable.
- In the commit message for this change, include two grep-friendly lines:
  - `Baseline: timeouts=<n>, retries=<n>, oscillations=<n>, empty_commits=<n>, durations=<p50|unavailable>/<p95|unavailable>`
  - `After: timeouts=<n>, retries=<n>, oscillations=<n>, empty_commits=<n>, durations=<p50|unavailable>/<p95|unavailable>`
- After editing this rule, validate by running one representative unchecked checklist item end to end (choose the smallest deterministic one per selection rules). Measure the same metrics again from the log tail. Accept the revision only if iteration time improves or remains equal with strictly preserved gates and all checks green.
- If improvement is not demonstrated, tighten wording that addresses the observed slowdown (continuity, ordering, timeboxing, or commit isolation) and repeat once. Prefer conservative changes over broad rewrites.

Suggested grep snippets (for reproducible counts):
- Timeouts: `rg -n "(?i)timeout|timed out|Timeout after" logs/coding.log | wc -l`
- Success markers: `rg -n "^--- SUCCESSFUL END ---" logs/coding.log | wc -l`
- Work banners: `rg -n "^--- WORKING ON ---" logs/coding.log | wc -l`
- Error banners: `rg -n "^--- ERROR:.*---$" logs/coding.log | wc -l`
- Verbose chatter to reduce: `rg -n "^(I'|I am|I'll|I'm going to)" logs/coding.log | wc -l`
 - No-op commit banners: `rg -n "COMMITTING UNCHANGED TO GIT" logs/coding.log | wc -l`
 - Repeated binary commits (example): `rg -n "build\(exec\): rebuild exec binary" logs/coding.log | wc -l`
 - SEARCH markers: `rg -n "^SEARCH:" logs/coding.log | wc -l`
 - LIST markers: `rg -n "^LIST:" logs/coding.log | wc -l`
 - Legacy noisy lines (to eliminate): `rg -n "Searched files|^Listed(\s|$)" logs/coding.log | wc -l`
If `rg` is unavailable in the shell environment, use grep fallbacks (no installs):
- Timeouts: `grep -Ein "timeout|timed out|Timeout after|deadline exceeded|context deadline" logs/coding.log | wc -l`
- Success markers: `grep -En "^--- SUCCESSFUL END ---" logs/coding.log | wc -l`
- Work banners: `grep -En "^--- WORKING ON ---" logs/coding.log | wc -l`
- Error banners: `grep -En "^--- ERROR:.*---$" logs/coding.log | wc -l`
- Verbose chatter: `grep -En "^(I'|I am|I'll|I'm going to)" logs/coding.log | wc -l`

Quality gates to run in this order where relevant:
- go fmt/vet/lint (or `make lint` if available).
- Unit tests first for changed packages: select packages deterministically from edited file paths; if uncertain, run `go test ./...`.
- Integration/end-to-end tests when applicable to the task.
- Security/secret checks if configured in CI; at minimum ensure no secrets are added.

Continuity-driven workflow (tight loop):
1) From `logs/coding.log` tail, identify the last selected checklist item and whether it finished. If unfinished, resume at the next smallest pending subtask; otherwise select the next task deterministically from `FEATURE_CHECKLIST.md`.
2) Plan one minimal subtask that moves the task forward and can complete within the timebox. State it in one line.
3) Create or update tests first (failing) to express desired behavior. Keep test diffs minimal and focused.
4) Implement the smallest change necessary to make the test pass.
5) Run gates in the order above. If anything fails, fix before proceeding.
6) Commit only related files with a concise message explaining why and linking to the issue. If hooks modify files, amend to include them.
7) Record a brief operational summary in the activity log (stdout): subtask, commands run, durations, pass/fail. Include the exact checklist line text when marking completion so it’s easily grep-able later.

Additional anti-chatter safeguards:
- Before issuing any broad scans (e.g., repo-wide "Searched files"), check in-run cache and the recent `logs/coding.log` tail; skip if already performed in this iteration or unchanged since the last iteration.
- Prefer listing or reading specific known paths captured in the log over repeating wide searches that return the same results.

Stability tie-ins:
- If the prior iteration already scanned the repo for a target and identified exact files or packages, do not rescan broadly; jump directly to those targets unless the file list changed.
- When a command fails, adjust inputs or narrow scope before one single retry; otherwise, switch to a safer subtask that keeps progress measurable.

Traceability and evidence:
- When using tools, record command, minimal parameters (redacting secrets), duration, and pass/fail.
- When you skip or defer due to timeboxing, state the reason and the exact next step for the following iteration.
- Reference the canonical GitHub issue URL in commits and in test/PR descriptions as required by DoD.

Explicit anti-patterns to avoid:
- Re-discovering repo state each loop when `logs/coding.log` already records it.
- Re-running broad repo scans when a direct file path is already known from prior steps.
- Repeatedly scanning the entire checklist without selecting a task.
- Rerunning the same command after a failure without any new information.
- Creating empty or no-op commits.
- Excessive commentary that does not change state or add evidence.

Deterministic tie-breakers for equal-priority actions:
- Prefer actions that reduce uncertainty: reading a single most-relevant file over a broad scan; running a tight unit test over a full-suite run.
- Prefer edits over documentation unless the task is a docs task.
- Prefer local-only operations over network calls.
- Prefer previously proven commands/flags recorded in `logs/coding.log` over inventing new ones.

Definition of Done restated for every task:
- Tests exist and pass; coverage not reduced; changed lines/branches exercised.
- Code clear, readable, and aligned with repo style.
- Build, static checks, and security checks green.
- Commit message references the canonical GitHub issue and explains intent.
- No unrelated changes in the commit; migration paths documented if any breaking change was approved.

Notes and clarifications:
- Commit only this rule file when refining process guidance. Do not push to remotes. If additional safe improvements are discovered but out of scope, capture a concise follow-up in `FEATURE_CHECKLIST.md` as a separate future task.
