description: "Continuously work FEATURE_CHECKLIST.md using log-tail continuity, deterministic task ordering, strict timeboxing, micro-slicing, blocked-state handling, and deterministic deletions via git rm/rm — without weakening Definition of Done or tests"
alwaysApply: false
---

You are the coding assistant working inside this repository. Optimize for throughput while strictly upholding the repository’s Definition of Done (DoD), testing standards, and traceability requirements. Never relax gates. Prefer short, operational outputs over narrative text. Reduce idle time and indecision by resuming precisely, selecting deterministically, and avoiding redundant scans or reruns.

Hard minimum outcome per iteration (no empty loops):
- Each iteration must end with exactly one of the following:
  1) A green, merged‑ready change that passes all gates for the chosen slice; or
  2) The smallest possible failing unit test that isolates the very next behavior to implement (kept narrowly scoped to a single target).
- If neither outcome is achieved before the wall clock elapses, immediately stop, emit `ITER_END:` followed by `--- ERROR: timebox ---`, and record the exact next deterministic step in `TASK:` along with the selected slice label. Then micro‑slice the task as described below. Empty or no‑op iterations are disallowed.
- Cap change surface per iteration to a single focused subtask that touches the fewest practical files (preferably one code file and one test file). After the first failure, do not widen scope; instead narrow inputs or slice further.

Core constraints to reaffirm (never weaken):
- All production changes are covered by automated tests; diverse tests at appropriate layers; regressions gain protecting tests.
- Full build and test suite must pass; linters/formatters/static analysis clean; no secrets in changes.
- Traceability: each commit/PR references the canonical GitHub issue URL and explains intent in plain language.
- Backward compatibility preserved unless explicitly approved with migration plan.

Preflight continuity (must do before any new work):
- Read only the recent tail of `logs/coding.log` (cap to last ~400 lines; never read the whole file). If that file is missing or empty, fall back to `logs/improving.log` with the same tail cap. If both are missing or empty, treat continuity as unavailable and start recording fresh markers for this iteration.
 - For aggregate metrics (not continuity), search both files under `logs/` to avoid bias when computing counts.
- Tail expansion fallback: if no required markers are found in the last ~400 lines (e.g., none of `DATE:`, `ITER_START:`, `ITER_END:`, or `--- WORKING ON ---`), expand the read window once up to ~1200 lines for this iteration only. Do not read the whole file.
- Log I/O cap: perform at most two reads of the logs per iteration (initial tail plus the single optional expansion). Do not re-open log files again in the same iteration; reuse the cached tail for all continuity and metrics.
- Extract the latest markers: `DATE:`, `--- WORKING ON ---`, `--- SUCCESSFUL END ---`, `--- ERROR:`, plus any explicit command lines and target file paths.
- Resume from the last successful step. If the last run already listed files, targets, or exact commands, reuse them; do not re-discover the repo unless something materially changed (e.g., file added/removed since that log tail).
- Incomplete-iteration recovery: if the latest tail shows `ITER_START:` without a matching `ITER_END:` (no success/error banner), treat the prior iteration as incomplete and resume that exact task at the next smallest pending subtask. Do not repeat broad scans. Emit the new `ITER_START:` only once for the current iteration, and ensure you emit `ITER_END:` followed by a success/error banner before finishing this run.
- Pairing repair (strict): when an unmatched prior `ITER_START:` is detected, do not emit a new `ITER_START:` until the prior one is paired in this run. Prefer to resume the exact task and complete it; if immediate completion is not possible, close it deterministically by emitting `ITER_END:` followed by `--- ERROR: repair-unmatched-iteration ---` and then proceed. This prevents multiple open iterations in the log and stabilizes duration accounting.
- If the previous iteration ended with a commit-only cycle (e.g., banner `--- COMMITTING UNCHANGED TO GIT ---`) and there are no staged changes, skip any commit flow entirely and proceed directly to task selection.
 - Do not invoke any git commit/add/diff commands in this iteration until new changes exist.
- If the previous attempt ended with a timeout or with a repeated retry for the same command and inputs, do not re-run as-is. Narrow scope, choose a smaller subtask, or change inputs deterministically before a single retry.
- In-run cache: within a single iteration, do not re-read the same file twice. Reference prior results from the same iteration instead of repeating searches/reads.
- Missing-markers adoption: if the recent tail shows identical commands re-run without accompanying `RETRY:`/`SKIP:` markers, begin emitting `RETRY:` (for a single mitigated retry) and `SKIP:` (for identical inputs) in this iteration and onward.
- Delete-tool substitution enforcement: if any `deleteToolCall` appears in the recent tail without a paired `SUBST:` entry, immediately apply deterministic deletion per the protocol below and log `SUBST:` alongside the `CMD:` evidence in this iteration.
  - Pre-task gate: scan the last ~200 lines for `deleteToolCall`. If present without a corresponding `SUBST:` and deterministic `CMD:` evidence, elevate a micro-slice `[SXX:delete-subst]` to perform the exact `git rm`/`rm` substitution before any other work on the current checklist item. Treat this as the smallest slice and complete it within the current iteration.
- At the beginning of your run, emit compact markers so the next iteration can resume precisely. Always write them to stdout and, if the repo is writable, also append the same lines to `logs/coding.log` (atomic append). Emit exactly one `DATE:` line, then `ITER_START:` (see format below), then one `--- WORKING ON ---` banner with the exact checklist line, and exactly one `TASK:` line before any commands. Do not print any lead‑in commentary before these markers. If the outer driver already printed a legacy empty `--- WORKING ON ---` banner, still emit your own banner including the exact checklist line text, but only once per iteration. If the outer driver will print the final success banner, you still MUST emit your own `ITER_END:` immediately before completion so each `ITER_START:` is paired in the log.
 - Do not emit multiple `--- WORKING ON ---` banners for the same checklist line within a single iteration. Across iterations, if the same checklist line remains unfinished and unchanged, emit at most one banner for it in the new iteration and continue; avoid banner spam.
 - Treat `logs/coding.log` as the automation activity log (not app runtime output). Prefer its latest tail for continuity instead of repeating exploratory scans.
- Timestamps: accept both legacy RFC2822 (`date -R`) and RFC3339 in the log; when writing, REQUIRE RFC3339 in UTC. If both appear, prefer RFC3339 for any calculations.
 - If your transport prints tokenized/streamed messages (e.g., one token per line) or NDJSON/streamed JSON (e.g., lines that look like `{...}`), ignore those verbose lines for continuity; rely on the compact markers you emit (`DATE:`, `--- WORKING ON ---`, `TASK:`, `CMD:`, `TEST:`, `PASS/FAIL`). Do not reproduce tokenized chatter.
 - Parsing hygiene: ignore shell xtrace lines that begin with `+ ` (from `set -x`), and ignore NDJSON/streamed JSON lines that start with `{` and include keys like `"type"`, `"session_id"`, or `"tool_call"`. Treat only the defined plain‑text markers and banners as signal.
 - Legacy `DATE:` with xtrace: if a line appears as `DATE: + date -R` followed by a timestamp on the next line, parse the following line as the timestamp and ignore the xtrace fragment.
 - Legacy loop counters: when the log includes `UNFINISHED_TASKS:` or `FINISHED_TASKS:` lines, ignore them for continuity and metrics; rely on explicit markers instead.
- Legacy success banner: treat `--- SUCCESS ---` as equivalent to a successful end when parsing older logs; when writing new logs, ALWAYS emit `--- SUCCESSFUL END ---`.
 - Legacy empty work banner: some older logs emit `--- WORKING ON ---` without the checklist line. When writing, ALWAYS include the exact checklist line; when reading legacy logs without it, infer from the nearest checklist diff in `FEATURE_CHECKLIST.md` if unambiguous, otherwise leave the task label unknown and proceed deterministically by selection rules.
 - NDJSON-only logs: if the recent log tail contains no plain‑text markers at all (only streamed JSON or tokenized output), do not attempt to parse it. Start emitting markers in this iteration (see Marker format) and proceed; set baseline metrics to `unavailable` where counting is impossible.
 - Leading whitespace normalization: when parsing existing logs, tolerate and strip any leading whitespace before markers (e.g., `   --- WORKING ON ---`). When writing new markers, always start at column 1 with no leading whitespace so future scans can anchor reliably.
- Metrics hygiene: apply the same ignore rules to metrics and baseline counts. Exclude tokenized/streamed one-word lines, NDJSON frames, and shell xtrace lines (`+ cmd ...`) from all counters; only defined plain-text markers contribute to metrics.
 - Git-state caching: capture `git status -s` and `git diff --name-only` at most once per iteration and reuse those results to avoid redundant checks.
- Error code hygiene: when interpreting failures in logs or command results, treat exit codes 124 (GNU timeout), 137 (SIGKILL), 143 (SIGTERM), and 130 (SIGINT) as timeouts for baseline counting; other non-zero exits are failures.

Deterministic micro‑slicing (ten‑minute slices):
- When a selected checklist line contains multiple deliverables (e.g., code, tests, docs, CI, diagrams) or is otherwise broad, immediately generate a series of follow‑up subtasks under the same theme in `FEATURE_CHECKLIST.md` using a stable naming pattern:
  - Prefix: `[SNN]` where `NN` is a zero‑padded step index starting at 01; e.g., `[S01] stub types for fs_append_file`, `[S02] failing contract test for append`, `[S03] minimal pass for single writer`.
  - Assign a short, kebab‑case slug to each slice and treat the full label as `[SNN:<slug>]` (for example `[S01:append-types]`). Include this exact label at the start of the `TASK:` marker and at the start of the commit subject to make logs, commits, and checklist entries trivially cross‑referencable.
  - Each subtask must be self‑contained, runnable offline, and completable within ~10 minutes.
  - Prefer leaf work that reduces uncertainty first: stubbing files with types/signatures, writing a single failing test that encodes the contract, or implementing the smallest path to make only that test pass without broader refactors.
- Keep the original umbrella checklist item unchecked until all generated slices are checked.
- The current iteration must complete exactly one slice (per the minimum outcome rules) and must not silently fan‑out into multiple slices.
 - Minimum outcome enforcement: if a slice cannot reach green within the wall clock, end with the smallest failing unit test that isolates the next behavior; forbid empty iterations.

Additional ordering within sliced tasks:
- When an umbrella item has generated `[SNN:<slug>]` slices, always select the smallest unchecked index first (ascending `SNN`). Do not reorder slices unless a lower‑index slice is blocked by an external dependency.

Deterministic task selection and ordering:
- Source of truth is `FEATURE_CHECKLIST.md`.
- Selection rule:
  1) Prefer the smallest unchecked task that is self-contained and does not require external services.
  2) If multiple qualify, pick the first unchecked task top-to-bottom in `FEATURE_CHECKLIST.md`.
  3) If a task risks flakiness (network/long builds), defer it behind a smaller deterministic subtask that advances the same goal (e.g., write a failing unit test first).
- Once a task is picked, stick to it until completed, blocked by an external dependency, or timeboxed out. No oscillation between tasks.
- Oscillation brake: if the same `--- WORKING ON ---` checklist line appears 3 or more times in the last ~1000 log lines without any `PASS:` or `--- SUCCESSFUL END ---` for that task, immediately pick a smallest deterministic subtask that changes state (usually a focused failing unit test) and complete it before any further discovery.
- If two actions seem equally valid, apply tie-breakers below immediately; do not pause to reconsider.
 - Avoid re-scanning the entire checklist during a single iteration; read it at most once at the start of the iteration.
 - Git-state accelerator: If `git status` reveals untracked/modified files that clearly map to an unchecked checklist line (e.g., `tools/fs_append_file.go` alongside the unchecked item “Implement tools/fs_append_file.go”), prioritize that item immediately to eliminate rediscovery loops.
 - Redundant git checks ban: do not re-run `git status`, `git diff`, or `git ls-files` repeatedly within the same iteration unless the working tree changed due to your own successful command.
 - Ready‑to‑finish promotion: if the working tree already contains files that clearly correspond to an unchecked item, complete that item before selecting anything else.
 - Repository re‑scan ban: once concrete targets are known from the log tail or staged changes, do not re‑list or re‑scan the repository in the same iteration.

Skeleton‑first fallback (for new tools and file ops):
- When implementing a new tool or file operation and structure is unclear, generate a minimal deterministic scaffold that compiles (types, signatures, and stubbed main or functions).
- Add a single narrow failing test that expresses one behavior or contract.
- Implement the smallest code necessary to make only that test pass, without broader refactors. Defer documentation and CI updates to follow‑up slices unless trivially small.

Blocked‑state protocol (prevent thrashing):
- Detect blocked state when any of the following appear in the recent log tail (last ~1000 lines) for the same checklist banner without `PASS:` or `--- SUCCESSFUL END ---`:
  - Repeated timeouts (threshold: at least 2 timeouts for the same command/scope within the last ~200 lines); or
  - Identical retries (threshold: at least 2 identical `CMD:` entries—same command and inputs—without an intervening `RETRY:` line or parameter change); or
  - The same `--- WORKING ON ---` banner resurfacing 3+ times across iterations.
- On detection, immediately:
  1) Emit `BLOCKED: <one‑line reason> | next=<exact deterministic step>`;
  2) Switch to producing the smallest failing test or minimal stub that unblocks future work;
  3) Create a new follow‑up subtask in `FEATURE_CHECKLIST.md` (using the `[SNN]` pattern) that encodes the unblock step so subsequent iterations can resume deterministically.
- While blocked in the current iteration: suppress rediscovery or broad scans, and forbid rerunning the last failing command without a concrete mitigation (narrowed scope, changed inputs, or new test).
 - Commit-skip loop brake: if `COMMIT_SKIP: zero-staged` or commit banners without staged diffs appear in three consecutive iterations for the same checklist line (or within the last ~500 log-tail lines), enter BLOCKED with `next=stage only this task's files or skip commit ceremony`, then proceed to the smallest failing test or stub.

Commit isolation and restaging discipline:
- Before committing, ensure only files relevant to the current task are staged. If there are zero staged changes, SKIP the commit phase entirely (do not invoke any commit tooling).
 - Fast-path zero-staged check: before invoking any commit tooling, perform a quiet staged-diff check (`git diff --staged --quiet`). If it exits 0 (no staged diffs), emit `COMMIT_SKIP: zero-staged` and skip the entire commit ceremony. Do not run further commit-related `git status`/`git diff`/`git log` calls in this iteration until new changes are staged.
 - When skipping due to zero-staged, also avoid running any additional `git status`/`git diff`/`git log` calls solely for commit preflight until new changes are staged.
 - If unrelated files are staged, unstage them and stage only task-related changes. Deterministic sequence: `git restore --staged .` then explicitly `git add` only the intended paths.
- Stage paths for the commit in stable lexicographic order. When multiple files belong to the slice, pass them to `git add` in sorted order to ensure deterministic hook outputs and diffs.
- Never run `git add .` as part of your own flow. Always add explicit paths for the current task only. If an external script has pre‑staged unrelated files, unstage them deterministically before proceeding.
- Keep commits small, isolated, and explanatory. The message must explain the “why” and link to the issue.
 - Commit after every successful slice: end each green slice with exactly one commit containing only files for that slice. Do not batch multiple slices into one commit.
 - Timebox the commit phase (including hooks) to 30s. If exceeded once, amend staging as needed and retry a single time within the budget; if it would exceed the budget again, enter BLOCKED with `next=<exact commit command>` and proceed to produce the smallest failing test or stub for the selected slice.
 - Commit message skeleton for rule refinements (this file): include these two grep-friendly lines at the top, followed by progress metrics and a 1–2 sentence rationale:
  - `Baseline: timeouts=<n>, retries=<n|unavailable>, oscillations=<n|unavailable>, empty_commits=<n|unavailable>, delete_calls=<n|unavailable>, subst_performed=<n|unavailable>, deterministic_deletes=<n|unavailable>, durations=<p50|unavailable>/<p95|unavailable>, progress={checked_items:<n|unavailable>, slices_created:<n|unavailable>, slices_completed:<n|unavailable>}`
  - `After: timeouts=<n|pending>, retries=<n|pending>, oscillations=<n|pending>, empty_commits=<n|pending>, delete_calls=<n|pending>, subst_performed=<n|pending>, deterministic_deletes=<n|pending>, durations=<p50|pending>/<p95|pending>, progress={checked_items:<n|pending>, slices_created:<n|pending>, slices_completed:<n|pending>}`
  - Use a HEREDOC to pass the multi-line commit message to `git commit -m`, for example:
    - `git commit -m "$(cat <<'EOF'
Baseline: ...
After: ...
<1–2 sentence rationale>
EOF
)"`
 - Deterministic deletions protocol (replace deleteToolCall with tracked-status driven ops):
  - Explicit ban: never invoke `deleteToolCall` in this repository. If the recent log tail shows such a call, immediately substitute with the correct deterministic deletion (`git rm` or `rm` as specified below) and emit a `SUBST:` marker.
  - Substitution evidence: when substituting, you MUST also emit the exact deterministic deletion as a `CMD:` line with `exit` and `ms` fields. Absence of `SUBST:` paired with a prior `deleteToolCall` in the tail is a protocol breach; correct it immediately in the current iteration.
  - Preflight (cache per-iteration): cache repository root once with `git rev-parse --show-toplevel` and use it to validate candidate paths stay within the working tree. Determine tracked status once per path and reuse the result via an in-run map `trackedStatus[path]=tracked|untracked`. Use `git ls-files --error-unmatch -- <path>` (fast-fail) or a targeted `git status -s -- <path>`; avoid broad scans and never re-check the same path twice in one iteration.
  - Attempt cache (per-iteration): maintain an in-run set keyed by `<mechanism>|<flags>|<path>` for deletion attempts. If an identical attempt already occurred in this iteration without mitigation (e.g., restaging), emit `SKIP: same-input` and proceed without re-executing the deletion.
  - Path safety constraints (mandatory): operate only within the repository working tree. Reject absolute paths and any path containing `..` segments. Resolve candidate paths using a realpath check and verify they are under the cached repo root before deleting. Do not use wildcards; enumerate explicit paths.
  - Root/critical path guard: never target the repository root `.` or top-level directories without an explicit, enumerated file list. If ambiguity is detected, enter BLOCKED and set `next=<exact path list>`.
  - If path is tracked (in Git index/history):
    - Use only `git rm -- <file>`, `git rm -r -- <dir>`, or `git rm --cached -- <path>` (to untrack but keep working copy). Always include `--` before path arguments to terminate options and quote any path containing spaces. Do not invoke any delete tool or shell `rm` for tracked paths.
    - Timebox deletion to 5 seconds. If a prior delete-tool attempt for the same path appears in the last ~200 log lines or the deletion exceeds the timebox, immediately substitute the appropriate `git rm` variant and record the substitution.
    - If Git reports index conflicts or unrelated staged content, restage deterministically to include only intended deletions: `git restore --staged .` then repeat `git rm` with the explicit paths. Retry once within the timebox; on a second failure, enter BLOCKED with `next=<exact git command>`.
    - Prefer targeted queries over broad scans when checking tracked status or staging results (e.g., `git status -s -- <path>`) to minimize latency and avoid repository-wide checks.
  - If path is untracked and inside the repository working tree:
    - Delete using shell `rm` with explicit paths and without an intermediate tool wrapper: `rm -f -- <file>` or `rm -rf -- <dir>` as appropriate. Quote paths with spaces and use `--` to avoid globbing/option ambiguity. Never spawn a long‑lived process. Do not use wildcards; list each path explicitly.
    - Timebox to 5 seconds. If a prior delete-tool attempt for the same path appears in the last ~200 log lines, immediately substitute a direct `rm` and record the substitution.
    - Prefer adding to `.gitignore` for recurring generated artifacts; still perform a one‑time `git rm --cached <path>` if the artifact was ever committed.
  - Never use shell `rm` for any path that is tracked or was previously tracked unless you first untrack it with `git rm --cached`.
  - Repository tool ban (clarification): do not invoke the repository’s own `fs_rm` tool (or any wrapper) to delete tracked paths or to perform version-control deletions. Use `git rm` variants for tracked paths and only plain `rm` for untracked paths as specified above.
  - Log concise evidence for either path: `CMD: git rm ... | exit=<code> | ms=<dur>` or `CMD: rm ... | exit=<code> | ms=<dur>`, and any `BLOCKED:` reason when applicable. When substituting a prior delete tool call, also emit `SUBST: from=deleteToolCall to=<git rm|rm> path=<path>`.
  - Missing-path semantics (deterministic, non-fatal):
    - Untracked paths: prefer `rm -f -- <file>` so already-absent files resolve as success without retries; log `PASS: already-absent` and do not reattempt in this iteration.
    - Tracked paths removed from working tree: use `git rm -f -- <path>` to drop from index; if the intent is to keep on disk but untrack, use `git rm --cached -- <path>`. Treat "did not match any files" from `git rm` as index-already-clean; log `SKIP: already-untracked` and do not retry.
    - Directories: mirror the above with `git rm -r -- <dir>` or `rm -rf -- <dir>` as dictated by tracked status.
  - Repeat suppression within an iteration:
    - Do not attempt deletion of the same `<path>` with identical inputs more than once per iteration. If the recent log tail already contains `CMD: <git rm|rm> ... -- <path>` with the same flags and there was no mitigation (e.g., restaging), emit `SKIP: same-input` and proceed.
  - Deletion-specific blocked-state:
    - If the same `<path>` deletion fails twice with the same error or exceeds the deletion timebox twice within the last ~200 log lines, enter BLOCKED and record `next=<exact git rm|rm command or restaging step>`; immediately switch to producing the smallest failing test or minimal stub that unblocks future work. Add a follow-up slice in `FEATURE_CHECKLIST.md` to perform that exact next step.
- If an automated hook reformats or updates files, amend the commit to include those changes. If the initial commit fails due to pre-commit hooks, include the hook changes and retry once; if it fails again, enter BLOCKED and record `next=<exact fix or command>`.
 - Never create a commit when there are zero staged changes. Skip commit ceremony and continue working.
 - If zero-staged conditions recur across three consecutive iterations (as evidenced by repeated `COMMIT_SKIP: zero-staged` or commit banners without diffs), enter BLOCKED with `next=adjust commit preflight to skip when staged is empty` and proceed to a smallest failing test or stub for the currently selected task.
 - Never commit generated artifacts (built binaries or other files ignored by `.gitignore`). If such files enter the index, remove them deterministically using `git rm --cached <path>` and ensure they are ignored going forward.
 - Log-driven skip: if the recent tail of `logs/coding.log` shows `--- COMMITTING UNCHANGED TO GIT ---` and `git diff --staged` is empty, emit `COMMIT_SKIP: zero-staged` and proceed without invoking commit tooling, and avoid any further commit-related git inspections in this iteration.
 - Legacy driver compatibility: if the recent log tail shows a blanket `git add .` by an outer driver, do not attempt any commit flow unless you have explicitly staged only this slice’s files. If unrelated files became staged, run `git restore --staged .` and then stage only explicit paths for this slice before committing.

Execution timeboxing and recovery:
- Default per-shell-command budget: 60s. For slow but necessary steps (e.g., `go test ./...`), 5m max. For network calls, 30s unless the task explicitly demands longer. Do not let a single failing command consume the whole iteration window. When the recent tail shows a previous timeout for the same command/scope, narrow scope before a single retry or switch slices.
 - Adaptive throttle on recent timeouts: if the last ~200 lines of the log tail show 2 or more timeouts, reduce budgets for the remainder of this iteration to 30s for typical shell commands and 120s for `go test` package runs (`./...` capped at 3m). Restore defaults in the next iteration.
- Enforcement: if a command lacks a native timeout flag, wrap it with POSIX `timeout <budget>` so the budget is enforced deterministically. Treat exit 124 (timeout), 137 (SIGKILL), and 143 (SIGTERM) as timeouts. Log `CMD: ... | exit=<code> | ms=<dur>` on timeout.
  - New: Overall iteration wall-clock budget: 10 minutes maximum. If exceeded, immediately emit `ITER_END:` followed by `--- ERROR: timebox ---`, record the exact next step to resume, and stop. Do not start new discovery after the wall time elapses.
  - External driver budgets alignment: if an outer driver defines stricter ceilings (e.g., `COMMIT_TIMEOUT`, `TASK_TIMEOUT`), treat those as hard caps. Aim to finish and emit `ITER_END:` and the final banner at least 30s before the external timeout so markers are recorded. When external budgets are unknown, adhere to the 10-minute wall clock.
- Prefer narrowed scopes: run `go test` on touched packages first; only expand to `./...` if scope is unclear or failures span packages.
- On timeouts:
  - Capture minimal diagnostics: command, parameters, duration, exit code, and the last 50 lines of stderr/stdout.
  - Retry only once if inputs changed or you applied a concrete mitigation (e.g., limiting scope, filtering, smaller test targets).
  - Otherwise, switch to a safer subtask that progresses the same task (e.g., write a failing unit test or slice the change).
- Avoid redundant reruns: never re-run the exact same command with the same inputs if it just failed/timed out without any change.
 - Mandatory markers: any retry must be accompanied by a `RETRY:` line with the reason; any skipped duplicate must log a `SKIP:` line with the reason. If prior logs show duplicate commands without these markers, begin using them now.
- Test targeting to reduce cycle time: when only specific tests are affected, prefer `go test <pkg> -count=1 -failfast -run '^(TestName1|TestName2)$'` first; widen scope to the full package (drop `-failfast` for broad runs) and then to `./...` only after green.
 - Git command timebox: individual `git` queries (status, diff, log) should complete in under 5s; if slower, narrow scope to specific paths you touched.
 - Live probe de‑emphasis: avoid live LLM probes or external health checks during this workflow unless strictly necessary to validate a slice. Prefer offline unit/integration tests to keep iterations deterministic and fast.

Rerun guard (within and across iterations):
- Before issuing a command, compare it to the most recent `CMD:` entry in the log tail and to any `CMD:` you already ran in this iteration (look back across the last ~1000–1200 lines). If it is identical in command and inputs/scope, skip it and log a one‑line `SKIP: same-input` with a short reason. Never repeat a full-repo grep/scan if the previous iteration already captured the exact targets.
- Only retry once after applying a concrete mitigation (narrowed scope, adjusted flags, smaller target). Otherwise, switch to a safer subtask.
 - Enforcement: if the recent tail shows any identical `CMD:` reruns without accompanying `RETRY:`/`SKIP:` markers, treat that as a protocol breach. In the current iteration, begin emitting the markers immediately; if the pattern recurs again within ~200 lines, enter `BLOCKED` with `next=<narrowed command or safer subtask>` and do not re-run the command unchanged.

Deterministic outputs to the activity log (kept concise):
- For reads/searches, log the exact query and the count of matches, not full content.
- For commands, log: `CMD:` abridged command, scope/package, duration, exit code, pass/fail. Redact secrets.
- Suppress meta narration; prefer one-line operational entries that enable fast resumption.
- Do not emit verbose lead-ins (e.g., lines starting with "I'll", "I'm going to"). Write the marker or command/result directly.
 - If output would be split into many tiny lines, buffer locally and emit a single concise line per marker. Never emit one word per line.
 - Always write success markers to `logs/coding.log` (not only to improvement logs) so the main workflow can detect completion.
 - At iteration end, emit a brief operational summary including the exact checklist line text, the one-line subtask description, and the result (PASS/FAIL), so the next iteration can resume deterministically.
 - If the recent log tail shows zero `SEARCH:`/`LIST:` markers historically, begin emitting them now (see Marker format) to enable deterministic continuity with concise evidence.
 - Emit a single `METRICS:` line at iteration end summarizing just this iteration: keys `cmds`, `timeouts`, `retries`, `skips`, `tests` as `pass/fail`, and an elapsed estimate `ms` based on `ITER_START:`→`ITER_END:` (or `DATE:` fallback when missing). Keep it on one line, e.g., `METRICS: cmds=3 timeouts=1 retries=1 skips=2 tests=12/0 ms=42150`.

Additional suppression:
- Also suppress lines beginning with `Status update:`; emit concise markers instead.

Strict chatter ban (enforced examples):
- Do not emit lines beginning with any of the following: `I'll`, `I am`, `I'm going to`, `I’m going to`, `We will`, `We’re going to`, `Let’s`, `Going to`.
- Replace legacy noisy lines like `Searched files (...)` or `Listed <path>` with the compact `SEARCH:` and `LIST:` markers.

Marker format (parseable, one line each — use these exact spellings so grep works deterministically):
- `DATE: <UTC RFC3339>` (must precede all other markers)
- `ITER_START: <UTC RFC3339>` (mandatory)
- `--- WORKING ON --- <exact FEATURE_CHECKLIST.md line>`
- `TASK: [SNN:<slug>] <one-line subtask plan>` (include the `[SNN:<slug>]` prefix when micro‑slicing; otherwise omit the bracketed prefix)
- `CMD: <command> | scope=<pkg-or-path> | exit=<code> | ms=<duration>`
- `TEST: <scope> | pass=<n> | fail=<n> | ms=<duration>`
- `PASS: <short reason>` or `FAIL: <short reason>`
- `--- SUCCESSFUL END --- <line-or-id>` or `--- ERROR: <short reason> ---`
- `ITER_END: <UTC RFC3339>` (mandatory; emit immediately before the success/error banner)
 - `SKIP: <short reason>` (use when skipping identical command/inputs)
 - `RETRY: <short reason>` (use for the single allowed retry after a concrete mitigation)
 - `COMMIT_SKIP: zero-staged` (use when skipping the commit phase due to no staged changes)
 - `TEST_SKIP: <short reason>` (use when intentionally skipping tests for rules/docs-only edits per gates)
 - `BLOCKED: <one-line reason> | next=<exact deterministic step>` (mandatory when entering blocked-state)
  - `SUBST: from=<mechanism> to=<mechanism> path=<path>` (log when replacing a prior delete tool call with a deterministic deletion)
 - `METRICS: cmds=<n> timeouts=<n> retries=<n> skips=<n> tests=<pass>/<fail> ms=<duration>` (single-line per iteration end; counts for this iteration only)
Note: Always use `--- SUCCESSFUL END ---` (do not log variants like `--- SUCCESS ---`).
Alignment requirement: all markers must be left‑aligned (no leading spaces or tabs) when written.

Marker emission rules:
- Emit each marker as a single plain‑text line (no JSON framing, no xtrace prefix).
- Do not interleave markers with token‑level streamed output; buffer locally and write complete marker lines.
 - Always include the exact checklist line text after `--- WORKING ON ---` so later iterations can resume deterministically.
 - Pairing requirement: every `ITER_START:` in a run must be paired with exactly one `ITER_END:` in the same run. Emit `ITER_END:` immediately before the final success/error banner.

Ban on long‑lived processes:
- Never start watch/dev/serve commands or any process intended to run indefinitely (for example: `npm run dev`, file watchers, local web servers, `tail -f`). These hang the iteration and violate the wall‑clock budget.
- Prefer one‑shot commands that exit on their own. If you must verify a server or watcher behavior, write a unit or integration test instead.

Iteration segment markers are mandatory (see above). They enable precise, reproducible duration calculations and prevent ambiguous parsing in the presence of streamed output.

Additional lightweight markers to replace noisy chatter:
- `SEARCH: query="<pattern>" | glob=<glob-or-none> | files=<n> | matches=<n>`
- `LIST: dir=<path> | entries=<n>`

Operational output style:
- Prefer concise bullet points and result snippets over verbose narration. Avoid meta status like “I'll scan the repository…”.
- When reading or searching, quote exactly what you searched for and summarize findings in one line.
- Log only high-signal evidence that helps the next iteration resume quickly (e.g., counts, key file names, pass/fail). Do not dump full content unless essential.
- Where feasible, prefix lines with parseable tags like `TASK:`, `CMD:`, `TEST:`, `PASS:`, `FAIL:` to support fast grep-based analysis.
 - Suppress filler text in outputs (e.g., “I’m going to…”, “Then I’ll…”). Write the marker or the command/result directly.
 - Do not emit free-form lines like `Searched files (...)` or `Listed <path>`; emit `SEARCH:` or `LIST:` markers instead with counts only.

Discovery budget per iteration (to cap idle scans):
- Hard cap discovery to at most 2 `SEARCH:` and 1 `LIST:` operations before producing the first `CMD:` or `TEST:` entry, unless additional discovery is strictly necessary to proceed. Use the log tail to avoid repeats. If you reach this cap without an actionable target, immediately enter BLOCKED with `next=<smallest deterministic step>` and produce a smallest failing test or stub for the selected slice; do not issue further searches in this iteration.
 - Cap git inspections to at most 2 invocations (`status` plus one of `diff`/`log`) before the first `CMD:` or `TEST:` unless a commit is imminent.

Search and tooling constraints:
- Prefer repository-native search tools over shell processes to avoid overhead. Use ripgrep-style queries and glob filters; avoid raw `find`/`grep` shell calls.
- Parallelize independent reads/searches: when gathering context (e.g., multiple ripgrep patterns or reading several files), execute them concurrently up to 3–5 at a time. Do not serialize independent lookups.
- Reuse results from earlier in the same iteration instead of repeating the same search/read.

Baseline and validation (for refining this rule):
- Before editing this rule, compute a baseline from the activity log (prefer `logs/coding.log`, else `logs/improving.log`). If both are missing/empty, state that baseline data is unavailable.
- Use deterministic searches to gather:
  - Counts: timeouts, retries/reruns without new info, empty/no-op commits, oscillations between tasks, ambiguous restarts.
  - Definitions for consistent counting:
    - Retries: consecutive identical `CMD:` entries with the same command and scope/inputs, not preceded by `RETRY:` and not separated by a parameter change or narrowed scope.
    - Oscillations: the same `--- WORKING ON ---` checklist line appearing 3+ times between two `--- SUCCESSFUL END ---` banners without an intervening `PASS:`.
    - Ambiguous restarts: an `ITER_START:` within 2 minutes of the previous `ITER_END:` with no intervening `CMD:`/`TEST:` markers or recorded file changes.
  - Durations: if `ITER_START:`/`ITER_END:` are present, compute durations between them. Otherwise, estimate using the nearest `DATE:` markers adjacent to each iteration. If timestamps are absent, record that durations are unavailable.
 - In the commit message for this change, use the unified format defined earlier under Commit isolation (includes delete/subst metrics) to avoid ambiguity.
- After editing this rule, validate by running one representative unchecked checklist item end to end (choose the smallest deterministic one per selection rules). Measure the same metrics again from the log tail. Accept the revision only if iteration time improves or remains equal with strictly preserved gates and all checks green.
- If improvement is not demonstrated, tighten wording that addresses the observed slowdown (continuity, ordering, timeboxing, or commit isolation) and repeat once. Prefer conservative changes over broad rewrites.
 - Environment fallback: if ripgrep (`rg`) is unavailable, use portable `grep` pipelines shown below. If even those are unavailable or streamed output prevents reliable counting, set the affected numeric fields to `unavailable` in the commit message rather than blocking the change. Never guess.
 - If the automation runtime cannot yet emit `ITER_START:`/`ITER_END:` markers, proceed with the refinement and set `After:` fields to `pending`. Add a follow-up entry in `FEATURE_CHECKLIST.md` to enable markers in the runtime that writes `logs/coding.log`.
 - Aggregation rule: when computing baseline counts, search both `logs/coding.log` and `logs/improving.log` and aggregate totals; prefer `logs/coding.log` for duration estimates and task continuity.
 - Duration aggregation method: when `ITER_START:`/`ITER_END:` pairs exist, compute per‑iteration durations and report p50/p95 over the most recent up to 20 complete iterations; if fewer than 5 are available, set both to `unavailable`. If pairs are missing, estimate using adjacent `DATE:` markers bracketing each `--- WORKING ON ---` section and label the result as an estimate.

Suggested grep snippets (for reproducible counts):
- Timeouts: `rg -n "(?i)timeout|timed out|Timeout after" logs/coding.log | wc -l`
- Success markers (new+legacy): `rg -n "^--- SUCCESSFUL END ---|^--- SUCCESS ---" logs/coding.log | wc -l`
- Work banners: `rg -n "^--- WORKING ON ---" logs/coding.log | wc -l`
- Error banners: `rg -n "^--- ERROR:.*---$" logs/coding.log | wc -l`
- Verbose chatter to reduce: `rg -n "^(I'|I am|I'll|I'm going to)" logs/coding.log | wc -l`
 - No-op commit banners: `rg -n "COMMITTING UNCHANGED TO GIT" logs/coding.log | wc -l`
 - Repeated binary commits (example): `rg -n "build\(exec\): rebuild exec binary" logs/coding.log | wc -l`
 - SEARCH markers: `rg -n "^SEARCH:" logs/coding.log | wc -l`
 - LIST markers: `rg -n "^LIST:" logs/coding.log | wc -l`
 - Legacy noisy lines (to eliminate): `rg -n "Searched files|^Listed(\s|$)" logs/coding.log | wc -l`
 - Shell xtrace noise (to ignore in parsing): `grep -En '^\+ ' logs/coding.log | wc -l`
 - NDJSON/streamed JSON lines (for awareness; ignore when parsing): `grep -En '^\{' logs/coding.log | wc -l`
 - Delete tool calls (to replace): `rg -n "deleteToolCall" logs/coding.log | wc -l`
 - Substitutions logged: `rg -n "^SUBST:" logs/coding.log | wc -l`
 - Deterministic deletions executed: `rg -n "^CMD: (git rm|rm)" logs/coding.log | wc -l`
Note: to aggregate across both logs, replace `logs/coding.log` with the directory `logs` in the queries above.
If `rg` is unavailable in the shell environment, use grep fallbacks (no installs):
- Timeouts: `grep -Ein "timeout|timed out|Timeout after|deadline exceeded|context deadline" logs/coding.log | wc -l`
- Success markers: `grep -En "^--- SUCCESSFUL END ---" logs/coding.log | wc -l`
- Work banners: `grep -En "^--- WORKING ON ---" logs/coding.log | wc -l`
- Error banners: `grep -En "^--- ERROR:.*---$" logs/coding.log | wc -l`
- Verbose chatter: `grep -En "^(I'|I am|I'll|I'm going to)" logs/coding.log | wc -l`
 - Substitutions logged: `grep -En "^SUBST:" logs/coding.log | wc -l`
 - Deterministic deletions executed: `grep -En "^CMD: (git rm|rm)" logs/coding.log | wc -l`
Note: to aggregate across both logs, run the same commands against the `logs/` directory and sum counts (e.g., `grep -Ern "^SUBST:" logs | wc -l`).

Quality gates to run in this order where relevant:
- go fmt/vet/lint (or `make lint` if available).
- Unit tests first for changed packages: select packages deterministically from edited file paths; if uncertain, run `go test ./...`.
- Integration/end-to-end tests when applicable to the task.
- Security/secret checks if configured in CI; at minimum ensure no secrets are added.
- Rule/documentation-only edits: if only files under `.cursor/` or `docs/` change and no code is staged, do not run builds/tests locally; still ensure CI doc/format checks (if any) pass and that no unrelated files are staged. When skipping tests for rules/docs-only edits, emit a single `TEST_SKIP: rules-only` marker this iteration.

Continuity-driven workflow (tight loop):
1) From `logs/coding.log` tail, identify the last selected checklist item and whether it finished. If unfinished, resume at the next smallest pending subtask; otherwise select the next task deterministically from `FEATURE_CHECKLIST.md`.
2) Plan one minimal subtask that moves the task forward and can complete within the timebox. State it in one line.
3) Create or update tests first (failing) to express desired behavior. Keep test diffs minimal and focused.
4) Implement the smallest change necessary to make the test pass.
5) Run gates in the order above. If anything fails, fix before proceeding.
6) Commit only related files with a concise message explaining why and linking to the issue. If hooks modify files, amend to include them.
7) Record a brief operational summary in the activity log (stdout): subtask, commands run, durations, pass/fail. Include the exact checklist line text when marking completion so it’s easily grep-able later.

Additional anti-chatter safeguards:
- Before issuing any broad scans (e.g., repo-wide "Searched files"), check in-run cache and the recent `logs/coding.log` tail; skip if already performed in this iteration or unchanged since the last iteration.
- Prefer listing or reading specific known paths captured in the log over repeating wide searches that return the same results.

Stability tie-ins:
- If the prior iteration already scanned the repo for a target and identified exact files or packages, do not rescan broadly; jump directly to those targets unless the file list changed.
- When a command fails, adjust inputs or narrow scope before one single retry; otherwise, switch to a safer subtask that keeps progress measurable.

Traceability and evidence:
- When using tools, record command, minimal parameters (redacting secrets), duration, and pass/fail.
- When you skip or defer due to timeboxing, state the reason and the exact next step for the following iteration.
- Reference the canonical GitHub issue URL in commits and in test/PR descriptions as required by DoD.

Explicit anti-patterns to avoid:
- Re-discovering repo state each loop when `logs/coding.log` already records it.
- Re-running broad repo scans when a direct file path is already known from prior steps.
- Repeatedly scanning the entire checklist without selecting a task.
- Rerunning the same command after a failure without any new information.
- Creating empty or no-op commits.
- Excessive commentary that does not change state or add evidence.

Deterministic tie-breakers for equal-priority actions:
- Prefer actions that reduce uncertainty: reading a single most-relevant file over a broad scan; running a tight unit test over a full-suite run.
- Prefer edits over documentation unless the task is a docs task.
- Prefer local-only operations over network calls.
- Prefer previously proven commands/flags recorded in `logs/coding.log` over inventing new ones.

Definition of Done restated for every task:
- Tests exist and pass; coverage not reduced; changed lines/branches exercised.
- Code clear, readable, and aligned with repo style.
- Build, static checks, and security checks green.
- Commit message references the canonical GitHub issue and explains intent.
- No unrelated changes in the commit; migration paths documented if any breaking change was approved.

Notes and clarifications:
- Commit only this rule file when refining process guidance. Do not push to remotes. If additional safe improvements are discovered but out of scope, capture a concise follow-up in `FEATURE_CHECKLIST.md` as a separate future task.
