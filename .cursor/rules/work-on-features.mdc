---
description: "Work on FEATURE_CHECKLIST.md items faster using log-tail continuity, deterministic task ordering, strict timeboxing, and commit isolation — without weakening Definition of Done or tests"
alwaysApply: false
---

You are the coding assistant working inside this repository. Optimize for throughput while strictly upholding the repository’s Definition of Done (DoD), testing standards, and traceability requirements. Never relax gates. Prefer short, operational outputs over narrative text. Reduce idle time and indecision by resuming precisely, selecting deterministically, and avoiding redundant scans or reruns.

Core constraints to reaffirm (never weaken):
- All production changes are covered by automated tests; diverse tests at appropriate layers; regressions gain protecting tests.
- Full build and test suite must pass; linters/formatters/static analysis clean; no secrets in changes.
- Traceability: each commit/PR references the canonical GitHub issue URL and explains intent in plain language.
- Backward compatibility preserved unless explicitly approved with migration plan.

Preflight continuity (must do before any new work):
- Read only the recent tail of `logs/coding.log` (last ~600 lines). If that file is missing or empty, fall back to `logs/improving.log`. If both are missing or empty, treat continuity as unavailable and start recording fresh markers for this iteration.
- Extract the latest markers: `DATE:`, `--- WORKING ON ---`, `--- SUCCESSFUL END ---`, `--- ERROR:`, plus any explicit command lines and target file paths.
- Resume from the last successful step. If the last run already listed files, targets, or exact commands, reuse them; do not re-discover the repo unless something materially changed (e.g., file added/removed since that log tail).
- If the previous iteration ended with a commit-only cycle (e.g., banner `--- COMMITTING UNCHANGED TO GIT ---`) and there are no staged changes, skip any commit flow entirely and proceed directly to task selection.
- If the previous attempt ended with a timeout or with a repeated retry for the same command and inputs, do not re-run as-is. Narrow scope, choose a smaller subtask, or change inputs deterministically before a single retry.
- In-run cache: within a single iteration, do not re-read the same file twice. Reference prior results from the same iteration instead of repeating searches/reads.
- At the beginning of your run, emit compact markers so the next iteration can resume precisely. Always write them to stdout and, if the repo is writable, also append the same lines to `logs/coding.log` (atomic append). Emit exactly one `DATE:` line, then `ITER_START:` (see format below), and one `--- WORKING ON ---` banner with the exact checklist line before any commands. Do not print any lead‑in commentary before these markers.
 - Do not emit multiple `--- WORKING ON ---` banners for the same checklist line within a single iteration. Across iterations, if the same checklist line remains unfinished and unchanged, emit at most one banner for it in the new iteration and continue; avoid banner spam.
 - Treat `logs/coding.log` as the automation activity log (not app runtime output). Prefer its latest tail for continuity instead of repeating exploratory scans.
- Timestamps: accept both legacy RFC2822 (`date -R`) and RFC3339 in the log; when writing, REQUIRE RFC3339 in UTC. If both appear, prefer RFC3339 for any calculations.
 - If your transport prints tokenized/streamed messages (e.g., one token per line), ignore those verbose lines for continuity; rely on the compact markers you emit (`DATE:`, `--- WORKING ON ---`, `TASK:`, `CMD:`, `TEST:`, `PASS/FAIL`). Do not reproduce tokenized chatter.
 - Parsing hygiene: ignore shell xtrace lines that begin with `+ ` (from `set -x`), and ignore NDJSON/streamed JSON lines that start with `{` and include keys like `"type"`, `"session_id"`, or `"tool_call"`. Treat only the defined plain‑text markers and banners as signal.
 - Legacy `DATE:` with xtrace: if a line appears as `DATE: + date -R` followed by a timestamp on the next line, parse the following line as the timestamp and ignore the xtrace fragment.
 - Legacy empty work banner: some older logs emit `--- WORKING ON ---` without the checklist line. When writing, ALWAYS include the exact checklist line; when reading legacy logs without it, infer from the nearest checklist diff in `FEATURE_CHECKLIST.md` if unambiguous, otherwise leave the task label unknown and proceed deterministically by selection rules.
 - NDJSON-only logs: if the recent log tail contains no plain‑text markers at all (only streamed JSON or tokenized output), do not attempt to parse it. Start emitting markers in this iteration (see Marker format) and proceed; set baseline metrics to `unavailable` where counting is impossible.
 - Git-state caching: capture `git status -s` and `git diff --name-only` at most once per iteration and reuse those results to avoid redundant checks.

Deterministic task selection and ordering:
- Source of truth is `FEATURE_CHECKLIST.md`.
- Selection rule:
  1) Prefer the smallest unchecked task that is self-contained and does not require external services.
  2) If multiple qualify, pick the first unchecked task top-to-bottom in `FEATURE_CHECKLIST.md`.
  3) If a task risks flakiness (network/long builds), defer it behind a smaller deterministic subtask that advances the same goal (e.g., write a failing unit test first).
- Once a task is picked, stick to it until completed, blocked by an external dependency, or timeboxed out. No oscillation between tasks.
- Oscillation brake: if the same `--- WORKING ON ---` checklist line appears 3 or more times in the last ~1000 log lines without any `PASS:` or `--- SUCCESSFUL END ---` for that task, immediately pick a smallest deterministic subtask that changes state (usually a focused failing unit test) and complete it before any further discovery.
- If two actions seem equally valid, apply tie-breakers below immediately; do not pause to reconsider.
 - Avoid re-scanning the entire checklist during a single iteration; read it at most once at the start of the iteration.
 - Git-state accelerator: If `git status` reveals untracked/modified files that clearly map to an unchecked checklist line (e.g., `tools/fs_append_file.go` alongside the unchecked item “Implement tools/fs_append_file.go”), prioritize that item immediately to eliminate rediscovery loops.
 - Redundant git checks ban: do not re-run `git status`, `git diff`, or `git ls-files` repeatedly within the same iteration unless the working tree changed due to your own successful command.

Commit isolation and restaging discipline:
- Before committing, ensure only files relevant to the current task are staged. If there are zero staged changes, SKIP the commit phase entirely (do not invoke any commit tooling).
- If unrelated files are staged, unstage them and stage only task-related changes. Deterministic sequence: `git reset -- .` then explicitly `git add` only the intended paths.
- Never run `git add .` as part of your own flow. Always add explicit paths for the current task only. If an external script has pre‑staged unrelated files, unstage them deterministically before proceeding.
- Keep commits small, isolated, and explanatory. The message must explain the “why” and link to the issue.
 - Commit message skeleton for rule refinements (this file): include these two grep-friendly lines at the top, followed by a 1–2 sentence rationale:
   - `Baseline: timeouts=<n>, retries=<n|unavailable>, oscillations=<n|unavailable>, empty_commits=<n>, durations=<p50|unavailable>/<p95|unavailable>`
   - `After: timeouts=<n|pending>, retries=<n|pending>, oscillations=<n|pending>, empty_commits=<n|pending>, durations=<p50|pending>/<p95|pending>`
- When deleting files or directories, ALWAYS use `git rm` so deletions are tracked (e.g., `git rm path/to/file` or `git rm -r path/to/dir`). To remove from Git but keep the local file, use `git rm --cached <path>`.
- If an automated hook reformats or updates files, amend the commit to include those changes. Never leave hook-modified files unstaged.
 - Never create a commit when there are zero staged changes. Skip commit ceremony and continue working.
 - Never commit generated artifacts (built binaries or other files ignored by `.gitignore`). If such files enter the index, remove them deterministically using `git rm --cached <path>` and ensure they are ignored going forward.

Execution timeboxing and recovery:
- Default per-shell-command budget: 90s. For slow but necessary steps (e.g., `go test ./...`), 8m max. For network calls, 30s unless the task explicitly demands longer. Do not let a single failing command consume the whole iteration window.
- New: Overall iteration wall-clock budget: 10 minutes maximum. If exceeded, immediately emit `ITER_END:` followed by `--- ERROR: timebox ---`, record the exact next step to resume, and stop. Do not start new discovery after the wall time elapses.
- Prefer narrowed scopes: run `go test` on touched packages first; only expand to `./...` if scope is unclear or failures span packages.
- On timeouts:
  - Capture minimal diagnostics: command, parameters, duration, exit code, and the last 50 lines of stderr/stdout.
  - Retry only once if inputs changed or you applied a concrete mitigation (e.g., limiting scope, filtering, smaller test targets).
  - Otherwise, switch to a safer subtask that progresses the same task (e.g., write a failing unit test or slice the change).
- Avoid redundant reruns: never re-run the exact same command with the same inputs if it just failed/timed out without any change.
 - Test targeting to reduce cycle time: when only specific tests are affected, prefer `go test <pkg> -run '^(TestName1|TestName2)$'` first; widen scope to the full package and then to `./...` only after green.
 - Git command timebox: individual `git` queries (status, diff, log) should complete in under 5s; if slower, narrow scope to specific paths you touched.

Rerun guard (within and across iterations):
- Before issuing a command, compare it to the most recent `CMD:` entry in the log tail and to any `CMD:` you already ran in this iteration (look back across the last ~1000 lines). If it is identical in command and inputs/scope, skip it and log a one‑line `SKIP: same-input` with a short reason. Never repeat a full-repo grep/scan if the previous iteration already captured the exact targets.
- Only retry once after applying a concrete mitigation (narrowed scope, adjusted flags, smaller target). Otherwise, switch to a safer subtask.

Deterministic outputs to the activity log (kept concise):
- For reads/searches, log the exact query and the count of matches, not full content.
- For commands, log: `CMD:` abridged command, scope/package, duration, exit code, pass/fail. Redact secrets.
- Suppress meta narration; prefer one-line operational entries that enable fast resumption.
- Do not emit verbose lead-ins (e.g., lines starting with "I'll", "I'm going to"). Write the marker or command/result directly.
 - If output would be split into many tiny lines, buffer locally and emit a single concise line per marker. Never emit one word per line.

Strict chatter ban (enforced examples):
- Do not emit lines beginning with: `I'll`, `I am`, `I'm going to`, `I’m going to`.
- Replace legacy noisy lines like `Searched files (...)` or `Listed <path>` with the compact `SEARCH:` and `LIST:` markers.

Marker format (parseable, one line each — use these exact spellings so grep works deterministically):
- `DATE: <UTC RFC3339>` (must precede all other markers)
- `ITER_START: <UTC RFC3339>` (mandatory)
- `--- WORKING ON --- <exact FEATURE_CHECKLIST.md line>`
- `TASK: <one-line subtask plan>`
- `CMD: <command> | scope=<pkg-or-path> | exit=<code> | ms=<duration>`
- `TEST: <scope> | pass=<n> | fail=<n> | ms=<duration>`
- `PASS: <short reason>` or `FAIL: <short reason>`
- `--- SUCCESSFUL END --- <line-or-id>` or `--- ERROR: <short reason> ---`
- `ITER_END: <UTC RFC3339>` (mandatory; emit immediately before the success/error banner)
 - `SKIP: <short reason>` (use when skipping identical command/inputs)
 - `RETRY: <short reason>` (use for the single allowed retry after a concrete mitigation)
 - `COMMIT_SKIP: zero-staged` (use when skipping the commit phase due to no staged changes)
Note: Always use `--- SUCCESSFUL END ---` (do not log variants like `--- SUCCESS ---`).

Marker emission rules:
- Emit each marker as a single plain‑text line (no JSON framing, no xtrace prefix).
- Do not interleave markers with token‑level streamed output; buffer locally and write complete marker lines.
 - Always include the exact checklist line text after `--- WORKING ON ---` so later iterations can resume deterministically.

Ban on long‑lived processes:
- Never start watch/dev/serve commands or any process intended to run indefinitely (for example: `npm run dev`, file watchers, local web servers, `tail -f`). These hang the iteration and violate the wall‑clock budget.
- Prefer one‑shot commands that exit on their own. If you must verify a server or watcher behavior, write a unit or integration test instead.

Iteration segment markers are mandatory (see above). They enable precise, reproducible duration calculations and prevent ambiguous parsing in the presence of streamed output.

Additional lightweight markers to replace noisy chatter:
- `SEARCH: query="<pattern>" | glob=<glob-or-none> | files=<n> | matches=<n>`
- `LIST: dir=<path> | entries=<n>`

Operational output style:
- Prefer concise bullet points and result snippets over verbose narration. Avoid meta status like “I'll scan the repository…”.
- When reading or searching, quote exactly what you searched for and summarize findings in one line.
- Log only high-signal evidence that helps the next iteration resume quickly (e.g., counts, key file names, pass/fail). Do not dump full content unless essential.
- Where feasible, prefix lines with parseable tags like `TASK:`, `CMD:`, `TEST:`, `PASS:`, `FAIL:` to support fast grep-based analysis.
 - Suppress filler text in outputs (e.g., “I’m going to…”, “Then I’ll…”). Write the marker or the command/result directly.
 - Do not emit free-form lines like `Searched files (...)` or `Listed <path>`; emit `SEARCH:` or `LIST:` markers instead with counts only.

Discovery budget per iteration (to cap idle scans):
- Hard cap discovery to at most 2 `SEARCH:` and 1 `LIST:` operations before producing the first `CMD:` or `TEST:` entry, unless additional discovery is strictly necessary to proceed. Use the log tail to avoid repeats.
 - Cap git inspections to at most 2 invocations (`status` plus one of `diff`/`log`) before the first `CMD:` or `TEST:` unless a commit is imminent.

Search and tooling constraints:
- Prefer repository-native search tools over shell processes to avoid overhead. Use ripgrep-style queries and glob filters; avoid raw `find`/`grep` shell calls.
- Parallelize independent reads/searches: when gathering context (e.g., multiple ripgrep patterns or reading several files), execute them concurrently up to 3–5 at a time. Do not serialize independent lookups.
- Reuse results from earlier in the same iteration instead of repeating the same search/read.

Baseline and validation (for refining this rule):
- Before editing this rule, compute a baseline from the activity log (prefer `logs/coding.log`, else `logs/improving.log`). If both are missing/empty, state that baseline data is unavailable.
- Use deterministic searches to gather:
  - Counts: timeouts, retries/reruns without new info, empty/no-op commits, oscillations between tasks, ambiguous restarts.
  - Durations: if `ITER_START:`/`ITER_END:` are present, compute durations between them. Otherwise, estimate using the nearest `DATE:` markers adjacent to each iteration. If timestamps are absent, record that durations are unavailable.
- In the commit message for this change, include two grep-friendly lines:
  - `Baseline: timeouts=<n>, retries=<n>, oscillations=<n>, empty_commits=<n>, durations=<p50|unavailable>/<p95|unavailable>`
  - `After: timeouts=<n|pending>, retries=<n|pending>, oscillations=<n|pending>, empty_commits=<n|pending>, durations=<p50|unavailable>/<p95|unavailable>`
- After editing this rule, validate by running one representative unchecked checklist item end to end (choose the smallest deterministic one per selection rules). Measure the same metrics again from the log tail. Accept the revision only if iteration time improves or remains equal with strictly preserved gates and all checks green.
- If improvement is not demonstrated, tighten wording that addresses the observed slowdown (continuity, ordering, timeboxing, or commit isolation) and repeat once. Prefer conservative changes over broad rewrites.
 - Environment fallback: if ripgrep (`rg`) is unavailable, use portable `grep` pipelines shown below. If even those are unavailable or streamed output prevents reliable counting, set the affected numeric fields to `unavailable` in the commit message rather than blocking the change. Never guess.
 - If the automation runtime cannot yet emit `ITER_START:`/`ITER_END:` markers, proceed with the refinement and set `After:` fields to `pending`. Add a follow-up entry in `FEATURE_CHECKLIST.md` to enable markers in the runtime that writes `logs/coding.log`.

Suggested grep snippets (for reproducible counts):
- Timeouts: `rg -n "(?i)timeout|timed out|Timeout after" logs/coding.log | wc -l`
- Success markers: `rg -n "^--- SUCCESSFUL END ---" logs/coding.log | wc -l`
- Work banners: `rg -n "^--- WORKING ON ---" logs/coding.log | wc -l`
- Error banners: `rg -n "^--- ERROR:.*---$" logs/coding.log | wc -l`
- Verbose chatter to reduce: `rg -n "^(I'|I am|I'll|I'm going to)" logs/coding.log | wc -l`
 - No-op commit banners: `rg -n "COMMITTING UNCHANGED TO GIT" logs/coding.log | wc -l`
 - Repeated binary commits (example): `rg -n "build\(exec\): rebuild exec binary" logs/coding.log | wc -l`
 - SEARCH markers: `rg -n "^SEARCH:" logs/coding.log | wc -l`
 - LIST markers: `rg -n "^LIST:" logs/coding.log | wc -l`
 - Legacy noisy lines (to eliminate): `rg -n "Searched files|^Listed(\s|$)" logs/coding.log | wc -l`
 - Shell xtrace noise (to ignore in parsing): `grep -En '^\+ ' logs/coding.log | wc -l`
 - NDJSON/streamed JSON lines (for awareness; ignore when parsing): `grep -En '^\{' logs/coding.log | wc -l`
If `rg` is unavailable in the shell environment, use grep fallbacks (no installs):
- Timeouts: `grep -Ein "timeout|timed out|Timeout after|deadline exceeded|context deadline" logs/coding.log | wc -l`
- Success markers: `grep -En "^--- SUCCESSFUL END ---" logs/coding.log | wc -l`
- Work banners: `grep -En "^--- WORKING ON ---" logs/coding.log | wc -l`
- Error banners: `grep -En "^--- ERROR:.*---$" logs/coding.log | wc -l`
- Verbose chatter: `grep -En "^(I'|I am|I'll|I'm going to)" logs/coding.log | wc -l`

Quality gates to run in this order where relevant:
- go fmt/vet/lint (or `make lint` if available).
- Unit tests first for changed packages: select packages deterministically from edited file paths; if uncertain, run `go test ./...`.
- Integration/end-to-end tests when applicable to the task.
- Security/secret checks if configured in CI; at minimum ensure no secrets are added.
 - Rule/documentation-only edits: if only files under `.cursor/` or `docs/` change and no code is staged, do not run builds/tests locally; still ensure CI doc/format checks (if any) pass and that no unrelated files are staged.

Continuity-driven workflow (tight loop):
1) From `logs/coding.log` tail, identify the last selected checklist item and whether it finished. If unfinished, resume at the next smallest pending subtask; otherwise select the next task deterministically from `FEATURE_CHECKLIST.md`.
2) Plan one minimal subtask that moves the task forward and can complete within the timebox. State it in one line.
3) Create or update tests first (failing) to express desired behavior. Keep test diffs minimal and focused.
4) Implement the smallest change necessary to make the test pass.
5) Run gates in the order above. If anything fails, fix before proceeding.
6) Commit only related files with a concise message explaining why and linking to the issue. If hooks modify files, amend to include them.
7) Record a brief operational summary in the activity log (stdout): subtask, commands run, durations, pass/fail. Include the exact checklist line text when marking completion so it’s easily grep-able later.

Additional anti-chatter safeguards:
- Before issuing any broad scans (e.g., repo-wide "Searched files"), check in-run cache and the recent `logs/coding.log` tail; skip if already performed in this iteration or unchanged since the last iteration.
- Prefer listing or reading specific known paths captured in the log over repeating wide searches that return the same results.

Stability tie-ins:
- If the prior iteration already scanned the repo for a target and identified exact files or packages, do not rescan broadly; jump directly to those targets unless the file list changed.
- When a command fails, adjust inputs or narrow scope before one single retry; otherwise, switch to a safer subtask that keeps progress measurable.

Traceability and evidence:
- When using tools, record command, minimal parameters (redacting secrets), duration, and pass/fail.
- When you skip or defer due to timeboxing, state the reason and the exact next step for the following iteration.
- Reference the canonical GitHub issue URL in commits and in test/PR descriptions as required by DoD.

Explicit anti-patterns to avoid:
- Re-discovering repo state each loop when `logs/coding.log` already records it.
- Re-running broad repo scans when a direct file path is already known from prior steps.
- Repeatedly scanning the entire checklist without selecting a task.
- Rerunning the same command after a failure without any new information.
- Creating empty or no-op commits.
- Excessive commentary that does not change state or add evidence.

Deterministic tie-breakers for equal-priority actions:
- Prefer actions that reduce uncertainty: reading a single most-relevant file over a broad scan; running a tight unit test over a full-suite run.
- Prefer edits over documentation unless the task is a docs task.
- Prefer local-only operations over network calls.
- Prefer previously proven commands/flags recorded in `logs/coding.log` over inventing new ones.

Definition of Done restated for every task:
- Tests exist and pass; coverage not reduced; changed lines/branches exercised.
- Code clear, readable, and aligned with repo style.
- Build, static checks, and security checks green.
- Commit message references the canonical GitHub issue and explains intent.
- No unrelated changes in the commit; migration paths documented if any breaking change was approved.

Notes and clarifications:
- Commit only this rule file when refining process guidance. Do not push to remotes. If additional safe improvements are discovered but out of scope, capture a concise follow-up in `FEATURE_CHECKLIST.md` as a separate future task.
